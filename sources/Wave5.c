#pragma config(Sensor, S1,     ,               sensorEV3_Color)
#pragma config(Sensor, S2,     ,               sensorEV3_Color)
#pragma config(Sensor, S3,     ,               sensorEV3_Ultrasonic)
#pragma config(Motor,  motorB,           ,             tmotorEV3_Large, openLoop, encoder)
#pragma config(Motor,  motorC,           ,             tmotorEV3_Large, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard !!*//

float black1, black2, white1 ,white2, grey1, grey2;
void kalib()
{ black1 = SensorValue[S1];
	black2 = SensorValue[S2];
	while(!getButtonPress(buttonUp))Sleep(1);

	white1 = SensorValue[S1];
	white2 = SensorValue[S2];
	while(!getButtonPress(buttonRight))Sleep(1);
	grey1=(black1+white1 )/2;
	grey2=(black2+white2)/2;
}
void move1()
{

	nMotorEncoder[motorB] = 0;
	motor[motorB] = 50;
	motor[motorC] = -50;
	while(nMotorEncoder[motorB]<300);//left//
		motor[motorB]=motor[motorC]=0;
	wait1Msec(1);



	nMotorEncoder[motorB] = 0;
	motor[motorB] = 30*1.86;
	motor[motorC] = 57*1.86;
	while(nMotorEncoder[motorB]<500);
	motor[motorB] = 0;
	motor[motorC] = 0;
	wait1Msec(5000);
	motor[motorB] = 50;
	motor[motorC] = 50;
	wait1Msec(5000);
	nMotorEncoder[motorB] = 0;
	motor[motorB] = 35*1.86;
	motor[motorC] = 50*1.86;
	while(nMotorEncoder[motorB]<340);
	motor[motorB] = 0;
	motor[motorC] = 0;
	wait1Msec(5000);
	//nMotorEncoder[motorB] = 0;
	motor[motorB] = 20*1.86;
	motor[motorC] = 30*1.86;
	while(SensorValue[S1]>	white1 -10);


	motor[motorB] = 50;
	motor[motorC] = -50;
	while(SensorValue[S2]>grey2-5);


	motor[motorB] = 0;
	motor[motorC] = 0;
	wait1Msec(100);





}
task main()
{float u,v,es,eold,e,k1=3.2,k2=9,n=1,d=35,r1,r2;
	es = SensorValue[S1]-SensorValue[S2];
	eold = 0;
	kalib();
	motor[motorB] = 0;
	motor[motorC] = 0;
	wait1Msec(1000);
	while (true)//////////
			while (SensorValue[S3]<d)//////////////
		if(SensorValue[S3]<d)/////////
	{	motor[motorB] = 0;
		motor[motorC] = 0;
		wait1Msec(800);
	}

	SensorValue[S3]=r1;
	motor[motorB] = 0;
	motor[motorC] = 0;
	wait1Msec(5000);
	SensorValue[S3]=r2;
	if(r1>r2)
	{
		motor[motorB] = 0;
		motor[motorC] = 0;

		/*		e = SensorValue[S1]-SensorValue[S2]-es;
		u = k1*e+k2*(e-eold);
		eold = e;
		v = 74-abs(u)*0.2;
		motor[motorB] = v+u;
		motor[motorC] = v-u;
		wait1Msec(1);

		else
		{

		motor[motorB] = 0;
		motor[motorC] = 0;
		wait1Msec(10);
		if(SensorValue[S3]>21)
		{	motor[motorB] = 0;
		motor[motorC] = 0;
		wait1Msec(100);}
		move1();
		}	*/


	}
}
