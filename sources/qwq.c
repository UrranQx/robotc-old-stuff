#pragma config(Sensor, S1,     ,               sensorEV3_Ultrasonic)
#pragma config(Sensor, S2,     ,               sensorEV3_Ultrasonic)
#pragma config(Sensor, S3,     ,               sensorEV3_Gyro)
#pragma config(Sensor, S4,     ,               sensorEV3_Color, modeEV3Color_Color)
#pragma config(Motor,  motorB,           ,             tmotorEV3_Large, openLoop, encoder)
#pragma config(Motor,  motorC,           ,             tmotorEV3_Large, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
int st=1;
float wk=1,W=100;//40
int angle = 0;
float V1=30, green=3, mas[120], len=0,alpha=69,beta=-68;//84.5
int fd=1;
task screen()
{
	while(true)
	{
		int Screen1=SensorValue[S1];
		int Screen2=SensorValue[S2];
		int angle=SensorValue[S3];
		displayBigTextLine(2,"Do stenkie1=%d",Screen1);
		displayBigTextLine(4,"Do stenkie2=%d",Screen2);
		displayBigTextLine(6,"UR angle is=%d",angle);
		sleep(1);
	}
}
task M()
{

	playTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
	playTone(  933,    7); wait1Msec(  75);  // Note(D#, Duration(32th))
	playTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
	playTone(  933,    7); wait1Msec(  75);  // Note(D#, Duration(32th))
	playTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
	playTone(  933,    7); wait1Msec(  75);  // Note(D#, Duration(32th))
	playTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
	playTone(  933,    7); wait1Msec(  75);  // Note(D#, Duration(32th))
	playTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
	playTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
	playTone(  933,    7); wait1Msec(  75);  // Note(D#, Duration(32th))
	playTone(  988,    7); wait1Msec(  75);  // Note(E, Duration(32th))
	playTone( 1047,    7); wait1Msec(  75);  // Note(F, Duration(32th))
	playTone( 1109,    7); wait1Msec(  75);  // Note(F#, Duration(32th))
	playTone( 1175,    7); wait1Msec(  75);  // Note(G, Duration(32th))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
	playTone( 1398,   14); wait1Msec( 150);  // Note(A#, Duration(16th))
	playTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	playTone(  784,   14); wait1Msec( 150);  // Note(C, Duration(16th))
	playTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
	playTone( 1047,   14); wait1Msec( 150);  // Note(F, Duration(16th))
	playTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	playTone( 1109,   14); wait1Msec( 150);  // Note(F#, Duration(16th))
	playTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
	playTone( 1398,   14); wait1Msec( 150);  // Note(A#, Duration(16th))
	playTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	playTone(  784,   14); wait1Msec( 150);  // Note(C, Duration(16th))
	playTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
	playTone( 1047,   14); wait1Msec( 150);  // Note(F, Duration(16th))
	playTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	playTone( 1109,   14); wait1Msec( 150);  // Note(F#, Duration(16th))
	playTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	playTone( 1398,   14); wait1Msec( 150);  // Note(A#, Duration(16th))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(  880,  108); wait1Msec(1200);  // Note(D, Duration(Half))
	playTone(    0,    7); wait1Msec(  75);  // Note(Rest, Duration(32th))
	playTone( 1398,   14); wait1Msec( 150);  // Note(A#, Duration(16th))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(  831,  108); wait1Msec(1200);  // Note(C#, Duration(Half))
	playTone(    0,    7); wait1Msec(  75);  // Note(Rest, Duration(32th))
	playTone( 1398,   14); wait1Msec( 150);  // Note(A#, Duration(16th))
	playTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
	playTone(  784,  108); wait1Msec(1200);  // Note(C, Duration(Half))
	playTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
	playTone(  932,   14); wait1Msec( 150);  // Note(A#5, Duration(16th))
	playTone(  784,   14); wait1Msec( 150);  // Note(C, Duration(16th))


}


void correction()
{
	int v=70,k=5,u;//k=2
	int k1=-5,l=5,l2=2,ct=50;//l-lenght
	if(SensorValue[S1]>28) ct=0;
	else ct=100;
	clearTimer(T1);
	nMotorEncoder[motorB]=0;
	nMotorEncoder[motorC]=0;
	while(time1[T1]<ct)
	{
		if(SensorValue[S1]<5)
		{v=k1*(SensorValue[S1]-l);}
		else
		{if (SensorValue[S1]>4&&SensorValue[S1]<25)
			{v=k1*(SensorValue[S1]-l2);}
			else
			{v=0;}
		}
		int e2=nMotorEncoder[motorB];
		int e3=nMotorEncoder[motorC];
		u=k*(e3-e2);
		motor[motorB]=v+u;
		motor[motorC]=v-u;
		//	wait1Msec(1);
	}
	//	motor[motorB]=motor[motorC]=0;
}
void l_gyro()
{
	resetGyro(S3);
	sleep(st);
	angle=SensorValue[S3];

	motor[motorB]=-W*wk;
	motor[motorC]=W*wk;
	angle=angle+beta;
	while (SensorValue[S3]>angle)
		sleep(10);
	//motor[motorB]=motor[motorC]=0;wait1Msec(100);
	correction();
	if(fd) mas[len++]=3;

}
void r_gyro()
{
	resetGyro(S3);
	sleep(st);
	angle=SensorValue[S3];

	angle=angle+alpha;
	motor[motorB]=W*wk;
	motor[motorC]=-W*wk;
	while (SensorValue[S3]<angle);
	//	motor[motorB]=motor[motorC]=0;wait1Msec(100);
	if(fd) mas[len++]=2;
}
void rightcore()
{	resetGyro(S3);
	sleep(st);
	angle=SensorValue[S3];

	angle=angle+alpha;
	motor[motorB]=W*wk;
	motor[motorC]=-W*wk;
	while (SensorValue[S3]<angle);
	correction();
}
void turnback ()
{
	resetGyro(S3);
	sleep(st);
	angle=SensorValue[S3];

	angle=angle+alpha;
	motor[motorB]=W*wk;
	motor[motorC]=-W*wk;
	while (SensorValue[S3]<(angle)*2);

}
void Sync_forward()
{
	int v=-100 ,k=5,u;
	nMotorEncoder[motorB]=0;
	nMotorEncoder[motorC]=0;
	while (nMotorEncoder[motorB]>-590)//old615
	{
		int e2=nMotorEncoder[motorB];
		int e3=nMotorEncoder[motorC];
		u=k*(e3-e2);
		motor[motorB]=v+u;
		motor[motorC]=v-u;
		wait1Msec(1);
	}

	correction();
	sleep(100);
	if(fd)
	{
		mas[len++]=1;
		if(SensorValue[S4]==green)
		{fd=0;}
	}
}
void Sync_forward2()
{
	int v=-100 ,k=5,u;
	nMotorEncoder[motorB]=0;
	nMotorEncoder[motorC]=0;
	while (nMotorEncoder[motorB]>-250)//old615
	{
		int e2=nMotorEncoder[motorB];
		int e3=nMotorEncoder[motorC];
		u=k*(e3-e2);
		motor[motorB]=v+u;
		motor[motorC]=v-u;
		wait1Msec(1);
	}

	correction();
	sleep(100);
	if(fd)
	{
		mas[len++]=4;
		if(SensorValue[S4]==green)
		{fd=0;}
	}
}
void massivSolver()
{
	for(int i=0;i<len;i++)
	{
		if(mas[i]==3 &&mas[i+1]==3/*left(180)*/&&mas[i-1]==mas[i+2]==1&&mas[i-2]==mas[i+3]==2)


		{	if(mas[i+4]==1)
			{for(int p=i-2;p<i+4;p++) mas[i]=0;


			}
		}
	}
}
void massivSolver2()
{
	for(int i=0;i<len;i++)
	{	displayBigTextLine(8,"Mas[i]=%d",i);
		if(mas[i]==3 &&mas[i+1]==3/*left(180)*/&&mas[i-1]==1&&mas[i+2]==1&&mas[i-2]==2&&mas[i+3]==2)
			sleep(700);

		//	{	if(mas[i+4]==1)
		//	{for(int p=i-2;p<i+4;p++)
		mas[i]=0;
		sleep(1000);

		//}
		//}
	}
}
void BeepBoop(){
	int pst=0;int pst1=1;
	int prev=-1;int prev2=-2;int prev3=-3;int prev4=-4;
	int next=2;int next2=3;int next3=4;int next4=5;


	wait1Msec(100);
	for(int i = 0;i<len;i++)//i=0;
	{
		if (mas[i+prev]==mas[i+next]==1&&mas[i+pst]==mas[i+pst1]==3&&mas[i+next2]==mas[i+prev2])
		{mas[i+pst]=mas[i+pst1]=mas[i+prev]=mas[i+next]=mas[i+prev2]=mas[i+next2]=0;
			playSound(soundDownwardTones);
		}
	}

}
void PTH()
{int n=1;

	for(int i=len/*-1*/;i>0;i--)
	{
		if (i==7&&n==1) {startTask (M);n=n*(-1);}
		switch(mas[i])
		{

		case 0: sleep(100);playSound(soundBeepBeep); break;
		case 1: Sync_forward(); break;
			//	case 2: r_gyro();break;
			//	case 3: l_gyro();break;
		case 2: l_gyro();break;
		case 3: /*r_gyro();*/ rightcore ();break;
		case 4:Sync_forward();break;
		}

	}

}

task main()
{ //0000
	for (int i=0;i<len;i++)
		mas[i]=0;
	resetGyro(S3);
	sleep(st);
	angle=SensorValue[S3];

	startTask (screen);
	//
	//vpered
	while(fd)
	{//
		if(SensorValue[S2]>21)
		{motor[motorB]=motor[motorC]=0;	wait1Msec(1);r_gyro();Sync_forward();
			///motor[motorB]=motor[motorC]=0;
			///	wait1Msec(1);//
		}
		else
		{
			if(SensorValue[S1]>21)
			{Sync_forward2();}
			else
			{motor[motorB]=motor[motorC]=0;	wait1Msec(1);l_gyro();}//
		}
	}
	//povorot
	playSound(soundException);
	//	BeepBoop();
	massivSolver();
	turnback();
	//massiv


	PTH();
	Sync_forward();
	turnback();
}
