#pragma config(Sensor, S1,     ,               sensorEV3_Color)
#pragma config(Sensor, S2,     ,               sensorEV3_Color)
#pragma config(Sensor, S3,     ,               sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,           ,             tmotorEV3_Large, openLoop, encoder)
#pragma config(Motor,  motorB,           ,             tmotorEV3_Large, openLoop, encoder)
#pragma config(Motor,  motorC,           ,             tmotorEV3_Large, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void move1()
{
	nMotorEncoder[motorB] = 0;
	motor[motorB] = -50;
	motor[motorC] = 50;
	while(nMotorEncoder[motorB]>-180);//right//
		motor[motorB]=motor[motorC]=0;
	wait1Msec(500);

	if (SensorValue[S3]>10)
	{


		nMotorEncoder[motorB] = 0;
		motor[motorB] = motor[motorC] = 50;

		while(nMotorEncoder[motorB]<250);//forward//
			wait1Msec(100);

		nMotorEncoder[motorB] = 0;
		motor[motorB] = 50;
		motor[motorC] = -50;
		while(nMotorEncoder[motorB]<173);//left//


		nMotorEncoder[motorB] = 0;
		motor[motorB] = motor[motorC] = 50;

		while(nMotorEncoder[motorB]<770);//forward//
			wait1Msec(100);

		nMotorEncoder[motorB] = 0;
		motor[motorB] = 50;
		motor[motorC] = -50;
		while(nMotorEncoder[motorB]<155);//left//

		nMotorEncoder[motorB] = 0;
		motor[motorB] = motor[motorC] = 50;

		while(nMotorEncoder[motorB]<335);//forward//
			wait1Msec(100);

		nMotorEncoder[motorB] = 0;
		motor[motorB] = -50;
		motor[motorC] = 50;
		while(nMotorEncoder[motorB]>-180);//right//
			wait1Msec(100);




	}
	else
	{//Left manuevor

		nMotorEncoder[motorB] = 0;
		motor[motorB] = 50;
		motor[motorC] = -50;
		while(nMotorEncoder[motorB]<290);//right//
			wait1Msec(100);

		nMotorEncoder[motorB] = 0;
		motor[motorB] = 30;
		motor[motorC] = 57;
		while(nMotorEncoder[motorB]<300);
		motor[motorB]=motor[motorC]=0;
		wait1Msec(5);
		nMotorEncoder[motorB] = 0;
		motor[motorB] = 36;
		motor[motorC] = 49;
		while(nMotorEncoder[motorB]<500);
		nMotorEncoder[motorB] = 0;
		motor[motorB] = 20;
		motor[motorC] = 20;
		while(nMotorEncoder[motorB]<110);//left//


		nMotorEncoder[motorB] = 0;
		motor[motorB] = 50;
		motor[motorC] = -50;
		while(nMotorEncoder[motorB]<90);//left//

		wait1Msec(100);


	}
}
task main()
{float u,v,es,eold,e,k1=7.7,k2=10;
	clearTimer(T1);
	int t=0;
	t=time1(T1);
	int silver1 = 35;
	int Silver2 = 42;
	es = SensorValue[S1]-SensorValue[S2];
	eold = 0;
	while((SensorValue[S1]<silver1&&SensorValue[S2]<silver1)||(SensorValue[S1]>=silver2&&SensorValue[S2]>=silver2))
	{displayBigTextLine(4,"%d",u);
		displayBigTextLine(6,"%d",SensorValue[S3]);
		if(SensorValue[S3]>6)
		{
			e = SensorValue[S1]-SensorValue[S2]-es;
			u = k1*e+k2*(e-eold);
			eold = e;
			v = 40-abs(u)*0.001;
			motor[motorB] = v+u;
			motor[motorC] = v-u;
			wait1Msec(1);
		}
		else
		{
			motor[motorB] = 0;
			motor[motorC] = 0;
			wait1Msec(100);

			move1();



		}


	}


}
