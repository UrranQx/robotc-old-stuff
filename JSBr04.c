#pragma config(Sensor, S1,     ,               sensorEV3_Color)
#pragma config(Sensor, S2,     ,               sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Motor,  motorB,           ,             tmotorEV3_Large, openLoop, encoder)
#pragma config(Motor,  motorC,           ,             tmotorEV3_Large, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//just some balancing robot
//JSBr


int gyroOffset,gyroRate,GyroRateOld=0,angVel;
int enc,encOld=0,encVel;
float encVelSoft=0;
float angle=0;
int dT=5,u;
float vk=1.0;
task main()
{
	sleep(100);resetGyro(S2);sleep(100);
	for(int i=0; i<10;i++)
	{
		gyroRate=getGyroRate(S2);
		if(gyroRate!=GyroRateOld) i=0;
		GyroRateOld=gyroRate;
		sleep(15);
		displayBigTextLine(1,"gyro rate=%d",getGyroRate(S2));
	}
	playSound(soundDownwardTones);
	gyroOffset=gyroRate;
	displayBigTextLine(5,"gyroOffset=%d",gyroOffset);
	nMotorEncoder[motorB]=nMotorEncoder[motorC]=0;
	sleep(100);resetGyro(S2);sleep(100);/////
	while(true)
	{
		angVel=getGyroRate(S2)-gyroOffset;
		angle=angle+angVel*dT*0.001;
		//gyroOffset = gyroRate * 0.002 + gyroOffset * 0.998;

		enc=(nMotorEncoder[motorB]+nMotorEncoder[motorC])/2;
		encVel=(enc-encOld);
		encOld=enc;
		encVelSoft=encVelSoft*0.9+ encVel*0.1;
		u=angVel*2.8 + angle*33 + enc*0.7 + encVelSoft*50;
		motor[motorB]=u*vk;
		motor[motorC]=u*vk;
		sleep(dT);


		displayBigTextLine(7,"angVel=%d",angVel);
		displayBigTextLine(9,"angle=%d",angle);



		//displayBigTextLine(3,"gyro degr=%d",getGyroDegrees(S2));
		//sleep(dT);
	}
















	/////



}
