#pragma config(Sensor, S1,     ,               sensorI2CHiTechnicCompass)
#pragma config(Sensor, S3,     HTIRS2,         sensorI2CCustom)
#pragma config(Sensor, S4,     ,               sensorEV3_Color, modeEV3Color_Color)
#pragma config(Motor,  motorB,           ,             tmotorEV3_Large, openLoop, encoder)
#pragma config(Motor,  motorC,           ,             tmotorEV3_Large, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int black=1;int alpha = 0,k=3 , beta=0;	int V=-30;int fd=1;
#include "hitechnic-irseeker-v2.h"
#include "hitechnic-compass.h"
task comp()
{float u,;

	tHTMC compass;
	initSensor(&compass,S2);
	sleep(200);
	readSensor(&compass);
	compass.offset=compass.heading;
	displayBigTextLine(4, "Target: %4d", compass.offset);
	wait1Msec(200);
	int err;
	alpha = beta = compass.heading;
	while(nMotorEncoder[motorB]>0)
	{
		readSensor(&compass);
		err=alpha-compass.heading;
		u=k*(err-err/180*360)*(1);//*-1
		motor[motorB]=V-u;
		motor[motorC]=V+u;
		wait1Msec(1);
	}
}
task main ()
{
	float u, v=50,err, ks=0.2,e=0;
	wait1Msec(100);
	tHTMC compass;
	initSensor(&compass, S2);
	sleep(200);
	readSensor(&compass);
	compass.offset = compass.heading;
	int alpha=compass.heading;
	tHTIRS2 irSeeker;
	initSensor(&irSeeker, S3);
	while(true)
	{ if (SensorValue[S4]<3)  //white
{			//readSensor(&compass);
if(SensorValue[S4]<black)
{
			readSensor(&irSeeker);
			if (irSeeker.acValues[2]>150)
			{
				readSensor(&compass);
				err=alpha-compass.heading;
				u=0.4*err;
			}
			else
			{

				e=alpha-compass.heading;
				e=e-(e/180)*360;
				int sector=5+ks*e/30.0;
				err=sector-irSeeker.acDirection;
				u=err*10;
			}}
			else
			{nMotorEncoder[motorB]=0;
			while(nMotorEncoder[motorB]>-120)
	{
	//	readSensor(&compass);
	//	err=alpha-compass.heading;
	//	u=k*(err-err/180*360)*(1);//*-1
		motor[motorB]=V;
		motor[motorC]=V;
	//	wait1Msec(1);
	}

			}
		}//if white//
		else
		{
			int vf=-50 ,kf=5,uf;
			nMotorEncoder[motorB]=0;
			nMotorEncoder[motorC]=0;
			while (nMotorEncoder[motorB]>-300)//old615
			{
				int e2=nMotorEncoder[motorB];
				int e3=nMotorEncoder[motorC];
				uf=kf*(e3-e2);
				motor[motorB]=vf+uf;
				motor[motorC]=vf-uf;
				wait1Msec(1);
			}
		}
		int mB=v-u;
		int mC=v+u;
		if (abs(mB)>100) mB=sgn(mB)*100;
		if (abs(mC)>100) mC=sgn(mC)*100;
		motor[motorB]=mB;
		motor[motorC]=mC;
		sleep(10);
	}
}
